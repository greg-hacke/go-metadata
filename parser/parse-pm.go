package parser

import (
	"bufio"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// TagTable represents a parsed ExifTool tag table
type TagTable struct {
	Name      string
	Namespace string
	Tags      map[string]TagDef
}

// TagDef represents a single tag definition
type TagDef struct {
	ID          string
	Name        string
	Description string
	Format      string
	Groups      map[string]string
	Values      map[string]string
}

// ParsePMFiles recursively parses all .pm files in the given directory
func ParsePMFiles(rootDir string) (map[string]*TagTable, error) {
	tables := make(map[string]*TagTable)

	err := filepath.WalkDir(rootDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if strings.HasSuffix(path, ".pm") && !d.IsDir() {
			table, err := parsePMFile(path)
			if err != nil {
				// Log error but continue processing other files
				fmt.Fprintf(os.Stderr, "Warning: failed to parse %s: %v\n", path, err)
				return nil
			}
			if table != nil {
				tables[table.Name] = table
			}
		}

		return nil
	})

	return tables, err
}

// parsePMFile parses a single .pm file
func parsePMFile(path string) (*TagTable, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	table := &TagTable{
		Tags: make(map[string]TagDef),
	}

	// Extract table name from filename
	baseName := filepath.Base(path)
	table.Name = strings.TrimSuffix(baseName, ".pm")

	scanner := bufio.NewScanner(file)
	var inTagTable bool
	var currentTag *TagDef
	var currentKey string

	// Regular expressions for parsing
	tagTableRe := regexp.MustCompile(`%Image::ExifTool::(\w+)::Main\s*=\s*\(`)
	tagDefRe := regexp.MustCompile(`^\s*(?:'([^']+)'|0x([0-9a-fA-F]+))\s*=>\s*\{`)
	nameRe := regexp.MustCompile(`Name\s*=>\s*'([^']+)'`)
	descRe := regexp.MustCompile(`Description\s*=>\s*'([^']+)'`)
	formatRe := regexp.MustCompile(`Format\s*=>\s*'([^']+)'`)
	printConvRe := regexp.MustCompile(`PrintConv\s*=>\s*\{([^}]+)\}`)

	for scanner.Scan() {
		line := scanner.Text()

		// Check for tag table start
		if matches := tagTableRe.FindStringSubmatch(line); matches != nil {
			table.Namespace = matches[1]
			inTagTable = true
			continue
		}

		if !inTagTable {
			continue
		}

		// Check for tag definition start
		if matches := tagDefRe.FindStringSubmatch(line); matches != nil {
			if currentTag != nil && currentKey != "" {
				table.Tags[currentKey] = *currentTag
			}

			currentTag = &TagDef{
				Groups: make(map[string]string),
				Values: make(map[string]string),
			}

			if matches[1] != "" {
				currentKey = matches[1]
				currentTag.ID = matches[1]
			} else {
				currentKey = "0x" + matches[2]
				currentTag.ID = currentKey
			}
			continue
		}

		// Parse tag properties
		if currentTag != nil {
			if matches := nameRe.FindStringSubmatch(line); matches != nil {
				currentTag.Name = matches[1]
			} else if matches := descRe.FindStringSubmatch(line); matches != nil {
				currentTag.Description = matches[1]
			} else if matches := formatRe.FindStringSubmatch(line); matches != nil {
				currentTag.Format = matches[1]
			} else if matches := printConvRe.FindStringSubmatch(line); matches != nil {
				// Parse value mappings
				parseValueMappings(matches[1], currentTag)
			}
		}

		// Check for table end
		if strings.Contains(line, ");") && inTagTable {
			if currentTag != nil && currentKey != "" {
				table.Tags[currentKey] = *currentTag
			}
			break
		}
	}

	if len(table.Tags) == 0 {
		return nil, nil // No tags found, skip this file
	}

	return table, scanner.Err()
}

// parseValueMappings parses PrintConv value mappings
func parseValueMappings(content string, tag *TagDef) {
	// Simple parser for value mappings like: 0 => 'None', 1 => 'Standard'
	valueRe := regexp.MustCompile(`(\d+)\s*=>\s*'([^']+)'`)
	matches := valueRe.FindAllStringSubmatch(content, -1)

	for _, match := range matches {
		if len(match) >= 3 {
			tag.Values[match[1]] = match[2]
		}
	}
}

// GenerateGoFile generates a Go source file for a tag table
func GenerateGoFile(table *TagTable, outputDir string) error {
	// Create output directory if it doesn't exist
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}

	// Generate filename
	filename := filepath.Join(outputDir, strings.ToLower(table.Namespace)+".go")

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write Go source
	fmt.Fprintf(file, "// Code generated by gen-tags. DO NOT EDIT.\n\n")
	fmt.Fprintf(file, "package tags\n\n")

	// Generate tag map variable name
	varName := table.Namespace + "Tags"

	fmt.Fprintf(file, "// %s contains tag definitions for %s\n", varName, table.Namespace)
	fmt.Fprintf(file, "var %s = map[string]TagDef{\n", varName)

	// Write tag definitions
	for id, tag := range table.Tags {
		fmt.Fprintf(file, "\t%q: {\n", id)
		fmt.Fprintf(file, "\t\tID:          %q,\n", tag.ID)
		fmt.Fprintf(file, "\t\tName:        %q,\n", tag.Name)
		fmt.Fprintf(file, "\t\tDescription: %q,\n", tag.Description)

		if tag.Format != "" {
			fmt.Fprintf(file, "\t\tFormat:      %q,\n", tag.Format)
		}

		if len(tag.Values) > 0 {
			fmt.Fprintf(file, "\t\tValues: map[string]string{\n")
			for k, v := range tag.Values {
				fmt.Fprintf(file, "\t\t\t%q: %q,\n", k, v)
			}
			fmt.Fprintf(file, "\t\t},\n")
		}

		fmt.Fprintf(file, "\t},\n")
	}

	fmt.Fprintf(file, "}\n")

	return nil
}
